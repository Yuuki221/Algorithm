Rearrange: 
=============
1. Move Zeroes: Given an array nums, write a function to move all 0s to the end of it while maintaining the relative order of the non-zero elements. 

> Do not need to remove reorder the array, 
> keep two pointers, only plus one the former pointer when meet non-zero element and iterate through the array use the second pointer
** Be carefule for the increase of i twice trap

Find Target:
===========
1. Contains Duplicate II
Given an array of integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the difference between i and j is at most k. 

 // Use hashtable 
> going through the array, put numbers in a hashtable, distinct number as hashtable keys and new duplicate index as value; 
> as updating the hashtable, if find any value larger than k, then return true; 

2. Contains Duplicate I
Given an array of integer, find if the array contains any duplicates. Your function should return true if any value appears at least twice in array , and it should return false if every element is distinct. 

> use a set to keep track of distinct memebers. 
> if found a duplicate then return true; 

Majority Element
================
1. Majority Element 
Given an array of size n, find the majority element. The majority element is the element that appears more than [n/2] times. 
Assume that the non-empty and the majority element always exist in the array

> sort and peak the middle item 
> Moore voting algorithm: 

Dynamic Difference Problem 
===========================
1. Best Time to Buy and Sell Stock
You have an array for which the ith element is the price of stock on day i. 

If you were only permitted to complete at most one transaction. 

> keep two global vars, first one is the smallest element so far, second is the largers profit so far 
> iterate through the array 


